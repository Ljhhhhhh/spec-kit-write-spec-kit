# 写代码之前先写文档？这才是不被 AI 绑架的正确姿势

周五下午 4 点，你正准备收拾东西下班，产品经理走过来："有个小需求，就是用户列表加个筛选和排序，很简单的。"你心里叹了口气，又来了...但确实看起来不复杂。

打开 Cursor，用自然语言描述："帮我实现用户列表的筛选和排序功能。"AI 飞快地工作，10 分钟后，200 行代码生成完毕。测试了几个场景，看起来都能用。太爽了！这就是 AI 时代的效率！你开心地下班了。

两周后，需求又来了："在筛选基础上增加高级筛选功能。"你打开那份 AI 生成的代码，愣住了：变量叫 `data1`、`temp`、`result2`，逻辑嵌套了 5 层 if-else，没有一行注释。你试着改了筛选逻辑，排序就出 bug 了。读了 1 小时代码，还是不确定所有的逻辑分支。最终你做了一个艰难的决定：推倒重写整个模块，花费 2 天时间。

10 分钟写完代码的快感，完全抵不过 2 天重构的煎熬。更让人不安的是，这不是个例。

## AI 写得快，但我们付出的代价是什么？

**代码质量像开盲盒。** AI 生成的代码能跑，但你不知道为什么能跑。每次生成结果都不同，质量不稳定。变量命名看心情，架构设计看运气。快速原型阶段很爽，维护阶段是灾难。技术债像滚雪球，越滚越大。就像吃外卖，当下很爽，但你不知道后厨什么样。

**不知道什么时候该主导，什么时候该放手。** 简单逻辑全交给 AI，自己只负责复制粘贴。复杂架构也想让 AI 帮忙，但又不放心。你不断在"全托管"和"全手写"之间摇摆，没有清晰的分工界限。不知道如何结构化协作，AI 成了"不太可靠的同事"而非工具。就像没有驾照就开自动驾驶，不知道什么时候该接管方向盘。

**感觉自己的架构能力在退化。** 习惯了"描述需求 → AI 生成"的模式，越来越少自己设计架构。遇到复杂问题，第一反应是"问 AI"而非"自己思考"。你担心过度依赖 AI，担心失去技术竞争力，担心变成"AI 的搬运工"。就像用惯了导航，不看导航就找不到路。

这些困扰的本质是什么？是 AI 不够强吗？

恰恰相反，是因为 **AI 太强了，而我们没有找到正确的协作方式**。

## 我们必须是定义问题和最终拍板的人

要找到正确的协作方式，我们需要回到一个本质问题：在 AI 时代，人的角色到底是什么？

AI 的本质是强大的执行工具，但不是决策者。人的优势在于理解业务、判断价值、承担责任。正确的关系应该是：**人定义"What"（做什么、为什么），AI 执行"How"（怎么实现）**。而不是人说一句模糊需求，AI 自由发挥，人被动接受。

这不是什么新理念，而是回归本质。行业观察发现，AI 编程助手虽然提高了编码速度，但需求到实现的"意图走样"问题反而加剧了。原因很简单：传统开发还有需求文档、架构设计作为"刹车"，AI 时代这些"刹车"常被跳过，导致从模糊需求直接到代码实现，意图衰减更严重。

根本原因是：缺少明确的"规格说明"作为锚点。

## Spec-Kit：让规格成为人机协作的桥梁

GitHub 推出的 Spec-Kit，正是为了解决这个问题。它是一个规格驱动开发（Spec-Driven Development）工具包，核心理念很简单：在 AI 编码前，先定义清晰的需求规格。

就像装修前的设计图纸，明确每个房间的布局和功能。Spec-Kit 不是要替代 AI 编程助手，而是让它们发挥更大价值。GitHub 明确指出，Spec-Kit 与 GitHub Copilot、Claude 等编码助手无缝集成，使开发者能够更准确地输入信息，从而减少错误和返工。就像给 AI 一份清晰的"设计图纸"，而不是让它凭感觉发挥。

**Spec-Kit 的核心工作流程：**

```
1️⃣ /specify - 写规格说明
   → 你用自然语言描述需求，但要写清楚：
   → 要做什么、边界条件、预期结果
   → AI 帮你结构化，形成完整规格文档

2️⃣ /plan - 技术规划
   → AI 根据规格生成技术方案
   → 识别数据模型、设计模式、测试用例
   → 你审核和拍板，而非被动接受

3️⃣ /tasks - 任务分解
   → 自动生成可执行的任务列表
   → 明确每个步骤的责任和顺序
   → 先写测试，再写实现（TDD）

4️⃣ /implement - 按规格实现
   → AI 辅助编码，但架构已定，不会跑偏
   → 你保持主导，AI 只是执行
```

与 vibe coding 的核心区别在哪？Vibe coding 是"AI，帮我做个功能" → AI 自由发挥 → 你被动接受。Spec-Kit 是"我先定义清楚要什么" → AI 按规格实现 → 你主导全程。关键差异是：**谁在定义问题**。前者快但不稳，后者稳且可迭代。

## 一个真实案例：30 小时 vs 9 小时

让我们看一个具体例子：开发一个用户权限管理功能。初始需求是实现管理员和普通用户两种角色，但现实中，后续会不断迭代（这才是真实项目的常态）。

**使用前：Vibe Coding 模式**

第一版（2 小时）：对 AI 说"帮我实现用户权限系统"，AI 生成代码，用了硬编码判断 `if (role === 'admin')`。测试通过，上线。

第一次迭代（4 小时）：需要增加"审核员"角色。发现代码中 8 处硬编码，不确定要改成 `role === 'admin' || role === 'reviewer'` 还是重构。小心翼翼地改了每一处，担心遗漏，焦虑感爆棚。

第二次迭代（24 小时）：需要增加"权限组"概念（一个用户多个权限）。震惊发现原有架构 `user.role`（单一字符串）完全不支持新需求 `user.roles`（数组）。**被迫推倒重来**，花费 3 天。

累计时间：**30 小时**。心理状态：每次迭代都崩溃。

**使用后：Spec-Kit 模式**

第一步（2 小时）：写规格 + 技术规划

```markdown
用户权限管理规格：

- 支持灵活的权限体系（未来可能增加新角色）
- 用户可以有一个或多个角色
- 权限检查需要可扩展（不能硬编码）
- 边界条件：无权限用户、权限冲突处理
```

AI 分析后生成方案：User、Role、Permission、UserRole（多对多关系）表，使用策略模式进行权限检查。**你审核和拍板**。

第二步（6 小时）：按任务列表实现，AI 辅助编码，但架构已定。

初版完成：8 小时（比 vibe coding 慢 6 小时）

第一次迭代（5 分钟）：增加"审核员"？在 roles 表增加一条记录即可，不用改代码。

第二次迭代（1 小时）：增加"权限组"？架构天然支持，只需添加 PermissionGroup 表和关联。

累计时间：**9.1 小时**。心理状态：迭代自信。

**数据对比：**

| 维度           | Vibe Coding | Spec-Kit | 差异           |
| -------------- | ----------- | -------- | -------------- |
| **初版速度**   | 2h          | 8h       | 慢 6h          |
| **第一次迭代** | 4h          | 0.1h     | 快 3.9h        |
| **第二次迭代** | 24h（重构） | 1h       | 快 23h         |
| **累计时间**   | **30h**     | **9.1h** | **节省 20.9h** |
| **代码质量**   | 技术债累积  | 架构清晰 | 质的差异       |
| **心智负担**   | 每次焦虑    | 迭代自信 | 心理优势       |

前期多投入 6 小时，后续节省 21 小时。**慢即是快，前期想清楚，后期少返工。**

## 三大困扰如何被解决

**困扰 1 解决：代码质量稳定了。** 因为规格明确了架构方向，变量命名有意义（数据模型清晰），逻辑不嵌套（设计模式指导），边界条件有测试覆盖。前期思考换来后期质量。就像按菜谱做菜，新手厨师（AI）也能做出稳定的菜品。

**困扰 2 解决：协作边界清晰了。** Spec-Kit 定义了明确的人机分工。你的责任是定义业务需求（/specify）、审核技术方案（/plan）、拍板重要决策。AI 的责任是生成技术方案、辅助编码实现、加速重复性工作。AI 是工具，不是决策者。你是导演（定剧本），AI 是摄影师（拍镜头）。

**困扰 3 解决：架构能力没退化，反而提升了。** Spec-Kit 强制你思考架构。每次都要写规格（锻炼需求分析），每次都要审核方案（锻炼架构判断），每次都要考虑扩展性（锻炼前瞻思维）。AI 是你的架构助手，不是替代。就像用导航的同时理解地图，你的方向感反而更强了。

## 如何开始：三步上手 Spec-Kit

**步骤 1：先体验，不求完美。** 访问 https://github.com/github/spec-kit \*\*，花 10 分钟浏览 README，理解核心理念。不需要立即全面使用，先把它当作"辅助工具"，而非"必须规范"。

**步骤 2：选择合适的功能尝试。** 挑一个中等复杂度的功能——不太简单（几行代码搞定），也不太复杂（架构不明确）。最好是需要迭代的功能，有一些边界条件需要考虑，你希望代码质量高一些。不选一次性脚本、紧急修复或极简单功能。

**步骤 3：对比体验。** 可以试试同一个功能，先用 vibe coding 做一版，再用 Spec-Kit 做一版。观察前期时间投入差异、代码质量差异、迭代时的心理感受。根据自己的体验判断是否继续使用。

## 它不是万能的：Spec-Kit 的适用边界

坦白说，不是所有场景都适合用 Spec-Kit。理解适用边界，才能发挥最大价值。

**适合用的场景：**  
✅ 需要长期维护的项目  
✅ 多人协作的项目  
✅ 复杂度中等以上的功能  
✅ 对代码质量有要求的项目

**不适合用的场景：**  
❌ 一次性脚本或原型（用完即扔）  
❌ 紧急临时修复（时间压力极大）  
❌ 学习探索阶段（方向不明确）  
❌ 极简单的功能（几行代码搞定）

> 💡 **如何判断是否该用 Spec-Kit？**
>
> 1. 这个功能会改吗？→ 很可能，用
> 2. 别人能看懂吗？→ 可能看不懂，用
> 3. 出问题能快速定位吗？→ 不确定，用

---

还是那个周五下午 4 点，产品经理还是那句"有个小需求"。

不同的是，这次你没有立即让 AI 生成代码。你花了 20 分钟写了一个简单的规格：功能目标是什么、需要考虑哪些边界条件、未来可能怎么扩展。然后让 AI 基于规格生成技术方案，你审核后拍板。

初版确实多花了 1 小时。但两周后的迭代，只花了 10 分钟。更重要的是，你保持了对代码的掌控感，而不是被 AI 牵着走。

AI 时代，不是比谁能让 AI 写得更快，而是比谁能更清楚地定义问题。Spec-Kit 不是在"慢下来"，而是在"想清楚"。想清楚了再做，反而是最快的路。

记住：**我们必须是定义问题和最终拍板的人**。这不是限制 AI，而是让 AI 成为我们更强大的工具。

---

**今天就可以做的三件事：**

1. 访问 https://github.com/github/spec-kit，了解 Spec-Kit 的核心理念
2. 在下次写功能前，尝试花 10 分钟写个简单规格，观察自己的感受
3. 思考一下：你是更焦虑了，还是更有掌控感了？

**互动邀请：**

- 你有类似的 vibe coding 翻车经历吗？欢迎在评论区分享
- 试用 Spec-Kit 后，期待听到你的体验和反馈
- 我们一起探讨 AI 时代更好的开发方式
